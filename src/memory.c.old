#include "memory.h"#define bool char#define FALSE (char) 0#define TRUE (char) 1#define MEM_32_MAX_ADDRESS 0xffffffff#define MEM_64_MAX_ADDRESS 0xffffffffffffffff#define MEM_MODE_IS_32 (memory_map.mode == MEM_32)#define MEM_MODE_IS_64 (memory_map.mode == MEM_64)#define IS_VALID_ADDRESS(addr) ( addr <= ( (MEM_MODE_IS_32) ? MEM_32_MAX_ADDRESS : ((MEM_MODE_IS_64) ? MEM_64_MAX_ADDRESS : 0 ) ) )#define PERM_IS_EXEC(perm) ((perm & MEM_EXEC) != 0)#define PERM_IS_WRITE(perm) ((perm & MEM_WRITE) != 0)#define PERM_IS_READ(perm) ((perm & MEM_READ) != 0)typedef struct {    char *     name;    MEM_ADDR    start_mem_address;    MEM_ADDR    end_mem_address;        size_t     size;    size_t      top;    void *      pointer;        MEM_PERMISSIONS perm;    bool        is_stack;} SECTION_STRUCT;typedef SECTION_STRUCT * SECTION;typedef struct {    size_t  nsections;    MEM_MODE mode;    SECTION text;    SECTION rodata;    SECTION data;    SECTION bss;    SECTION stack;    SECTION * memory_map;} MEM_MAP;static MEM_MAP memory_map = {0};static SECTION create_section( char * name, MEM_ADDR start_address, size_t size, MEM_PERMISSIONS perm, bool is_stack ) {    SECTION new_section = calloc( sizeof( SECTION_STRUCT ) ,1 );        if ( new_section == NULL )        goto cleanup;        #define end_addr start_address + size        if ( ! IS_VALID_ADDRESS(end_addr) )        goto cleanup;        new_section->name = name;        if ( is_stack ) {                if ( size > start_address )            goto cleanup;        new_section->start_mem_address = start_address - size;        new_section->end_mem_address = start_address ;        new_section->top = size;    }    else{        // If start_address+size is bigger then the boundary, then the sum is going to be lesser then start_address        if ( (memory_map.mode == MEM_64 && start_address + size < start_address ) || (memory_map.mode == MEM_32 && start_address + size < start_address ) )            goto cleanup;                new_section->start_mem_address = start_address;        new_section->end_mem_address = start_address + size;        new_section->top = 0;    }        new_section->pointer = calloc( size, 1 );    if ( new_section->pointer == NULL )        goto cleanup;        new_section->is_stack = is_stack;    new_section->perm = perm;    new_section->size = size;    #undef end_addr        return new_section;cleanup:    if (new_section)        free(new_section);        return NULL;}static void destroy_section( SECTION old_section ) {    free(old_section->pointer);    free(old_section);}static int sections_comparer( const void * p1, const void * p2 ) {    SECTION sect1 = (SECTION) *((SECTION *)p1);    SECTION sect2 = (SECTION) *((SECTION *)p2);     if ( sect1->start_mem_address < sect2->start_mem_address )        return -1;    else if ( sect1->start_mem_address > sect2->start_mem_address )        return 1;        return 0;}static int address_in_section( const void * addr_ptr, const void * sect_ptr ) {    SECTION sect = (SECTION) *((SECTION *)sect_ptr);    MEM_ADDR addr = *((MEM_ADDR *)addr_ptr);        if ( addr < sect->start_mem_address )        return -1;    else if ( addr >= sect->end_mem_address )        return 1;        return 0;}static SECTION search_address_section ( const MEM_ADDR addr ){    SECTION * sect_ptr = (SECTION *)bsearch( &addr, memory_map.memory_map, memory_map.nsections, sizeof(SECTION), address_in_section );        if ( sect_ptr == NULL )        return NULL;        return * sect_ptr;}//DEBUGstatic void print_section(SECTION sec){        printf("SECTION %s\n",      sec->name);        printf("\tstart: %p\n",     (void *)sec->start_mem_address);        printf("\tend: %p\n",       (void *)sec->end_mem_address);        printf("\tsize: %p\n",      (void *)sec->size);        printf("\tpointer: %p\n",   (void *)sec->pointer);        printf("\tperm: %p\n",      (void *)sec->perm);        printf("\tis_stack: %p\n",  (void *)sec->is_stack);        putchar('\n');}static void print_sections(){    for ( int i = 0; i < memory_map.nsections; i++ ) {        SECTION sec = memory_map.memory_map[i];        print_section(sec);    }}int memory_init( struct options * opt ) {    struct options fops = {0};    volatile MEM_ADDR sec_address;    volatile size_t sec_size;    SECTION temp;        if ( opt == NULL ) {            fops.mode = MEM_64;            fops.stack_start   = MEM_DEFAULT;            fops.text_start    = MEM_DEFAULT;            fops.rodata_start  = MEM_DEFAULT;            fops.data_start    = MEM_DEFAULT;            fops.bss_start     = MEM_DEFAULT;                        fops.stack_size    = MEM_DEFAULT;            fops.text_size     = MEM_DEFAULT;            fops.rodata_size   = MEM_DEFAULT;            fops.data_size     = MEM_DEFAULT;            fops.bss_size      = MEM_DEFAULT;            opt = &fops;        }        memory_map.mode = opt->mode;    memory_map.nsections = 5;// INITIALIZE SECTIONS//text_init:    sec_address = opt->text_start;    sec_size = opt->text_size;        if ( sec_address == MEM_DEFAULT ) {        if ( memory_map.mode == MEM_32 )            sec_address = TEXT_DEFAULT_ADDRESS_32;        else if ( memory_map.mode == MEM_64 )            sec_address = TEXT_DEFAULT_ADDRESS_64;        else            goto cleanup;    }        if ( sec_size == MEM_DEFAULT )        sec_size = TEXT_DEFAULT_SIZE;        if ((memory_map.text = create_section("text", sec_address, sec_size, MEM_READ | MEM_EXEC , FALSE)) == NULL )        goto cleanup;//rodata_init:    sec_address = opt->rodata_start;    sec_size = opt->rodata_size;        if ( sec_address == MEM_DEFAULT )        sec_address = memory_map.text->end_mem_address;            if ( sec_size == MEM_DEFAULT )        sec_size = RODATA_DEFAULT_SIZE;        if ((memory_map.rodata = create_section("rodata", sec_address, sec_size, MEM_READ, FALSE)) == NULL )        goto cleanup;//data_init:    sec_address = opt->data_start;    sec_size = opt->data_size;        if ( sec_address == MEM_DEFAULT )        sec_address = memory_map.rodata->end_mem_address;        if ( sec_size == MEM_DEFAULT )        sec_size = DATA_DEFAULT_SIZE;        if ((memory_map.data = create_section("data", sec_address, sec_size, MEM_READ | MEM_WRITE , FALSE)) == NULL )        goto cleanup;//bss_init:    sec_address = opt->bss_start;    sec_size = opt->bss_size;        if ( sec_address == MEM_DEFAULT )        sec_address = memory_map.data->end_mem_address;        if ( sec_size == MEM_DEFAULT )        sec_size = DATA_DEFAULT_SIZE;        if ((memory_map.bss = create_section("bss", sec_address, sec_size, MEM_READ | MEM_WRITE , FALSE)) == NULL )        goto cleanup;//stack_init:    sec_address = opt->stack_start;    sec_size = opt->stack_size;        if ( sec_address == MEM_DEFAULT ) {        if ( memory_map.mode == MEM_32 )            sec_address = STACK_DEFAULT_ADDRESS_32;        else if ( memory_map.mode == MEM_64 )            sec_address = STACK_DEFAULT_ADDRESS_64;        else            goto cleanup;    }        if ( sec_size == MEM_DEFAULT )        sec_size = STACK_DEFAULT_SIZE;        if ( sec_size == 0 )        goto cleanup;        if ((memory_map.stack = create_section("stack", sec_address, sec_size, MEM_READ | MEM_WRITE , TRUE)) == NULL )        goto cleanup;// INITIALIZE MEMORY MAP ARRAY    memory_map.memory_map = calloc( memory_map.nsections, sizeof(SECTION) );    if (memory_map.memory_map == NULL)        goto cleanup;        memory_map.memory_map[0] = memory_map.text;    memory_map.memory_map[1] = memory_map.rodata;    memory_map.memory_map[2] = memory_map.data;    memory_map.memory_map[3] = memory_map.bss;    memory_map.memory_map[4] = memory_map.stack;        qsort( memory_map.memory_map, memory_map.nsections, sizeof(SECTION), sections_comparer );// CHECK SECTION VALIDITY    for ( size_t i = 1; i < memory_map.nsections; i++ ) {        temp = memory_map.memory_map[i -1];        if ( temp->end_mem_address > (memory_map.memory_map[i])->start_mem_address ) {            goto cleanup;        }        if ( memory_map.mode == MEM_32 && ((memory_map.memory_map[i])->end_mem_address > MEM_32_MAX_ADDRESS) ){            goto cleanup;        }    }    return 0;    cleanup:    if ( memory_map.text )        destroy_section(memory_map.text);        if ( memory_map.rodata )        destroy_section(memory_map.rodata);        if ( memory_map.data )        destroy_section(memory_map.data);        if ( memory_map.bss )        destroy_section(memory_map.bss);        if ( memory_map.stack )        destroy_section(memory_map.stack);        if ( memory_map.memory_map )        free(memory_map.memory_map);    return -1;}int memory_destroy() {    for ( size_t i = 0; i < memory_map.nsections; i++ )        destroy_section( memory_map.memory_map[i] );        free(memory_map.memory_map);}size_t write_to_memory( MEM_ADDR address, void * buffer, size_t length ) {    SECTION sect = search_address_section(address);    size_t offset ;        if ( sect == NULL )        return 0;        if ( ! PERM_IS_WRITE(sect->perm) )        return 0;        offset = address - sect->start_mem_address;        if ( offset + length > sect->size )        return 0;    // the next feature could be writing/reading to the next section (if writable/readble)    memcpy( sect->pointer + offset, buffer, length );       if ( (sect->is_stack && ( offset + length < sect->top ) ) || offset + length > sect->top )        sect->top = offset + length;        return length;    }size_t read_from_memory(MEM_ADDR address, void * buffer, size_t length ){    SECTION sect = search_address_section(address);    size_t offset ;        if ( sect == NULL )        return 0;        if ( ! PERM_IS_READ(sect->perm) )        return 0;        offset = address - sect->start_mem_address;        if ( offset + length > sect->size )        return 0;    // the next feature could be writing/reading to the next section (if writable/readble)    memcpy(buffer, sect->pointer + offset, length );        return length;}/* * Privileged controllers, they do not modify the top field of the sector*/static size_t offset_write_to_section( SECTION sect, size_t offset, void * buffer, size_t length ){    if ( sect == NULL )        return 0;        if ( offset + length > sect->size )        return 0;    memcpy( sect->pointer + offset, buffer, length );    return length;}static size_t offset_read_from_section( SECTION sect, size_t offset, void * buffer, size_t length ){    if ( sect == NULL )        return 0;        if ( offset + length > sect->size )        return 0;    memcpy( buffer, sect->pointer + offset, length );    return length;}#define PRIVILEGED_WRITE( _S )                                              \do{           \    SECTION sect = _S ;   \    if( offset_write_to_section(sect, offset, buffer, length) != length )  \        return MEM_FAILURE;      \    return sect->start_mem_address + offset ;      \}while(0);#define PRIVILEGED_READ( _S )                                               \do{                                                                         \    SECTION sect = _S ;                                        \    if( offset_read_from_section(sect, offset, buffer, length) != length )  \        return MEM_FAILURE;       \    return sect->start_mem_address + offset ;     \}while(0); MEM_ADDR offset_write_text ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_WRITE( memory_map.text );}MEM_ADDR offset_write_rodata ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_WRITE( memory_map.rodata );}MEM_ADDR offset_write_data   ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_WRITE( memory_map.data );}MEM_ADDR offset_write_bss    ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_WRITE( memory_map.bss );}MEM_ADDR offset_write_stack    ( size_t offset, void * buffer, size_t length ){    SECTION sect = memory_map.stack ;    if ( sect == NULL )        return 0;        if ( offset > sect->size || offset < length )        return 0;    if( offset_write_to_section(sect, sect->size - offset, buffer, length) != length )        return MEM_FAILURE;        return sect->end_mem_address - offset ; }/* * Privileged reads*/MEM_ADDR offset_read_text ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_READ( memory_map.text );}MEM_ADDR offset_read_rodata ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_READ( memory_map.rodata );}MEM_ADDR offset_read_data   ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_READ( memory_map.data );}MEM_ADDR offset_read_bss    ( size_t offset, void * buffer, size_t length ){    PRIVILEGED_READ( memory_map.bss );}MEM_ADDR offset_read_stack    ( size_t offset, void * buffer, size_t length ){    SECTION sect = memory_map.stack ;    if ( sect == NULL )        return 0;        if ( offset > sect->size || offset < length )        return 0;    if( offset_read_from_section(sect, sect->size - offset, buffer, length) != length )        return MEM_FAILURE;        return sect->end_mem_address - offset ; }/* * Stack-like functions for adding data easily*/#define PUSH_SECTION(_S)    \do {    \    SECTION sect = _S; \    if (sect == NULL)   \        return MEM_FAILURE;   \    if ( sect->top + length > sect->size )   \        return MEM_FAILURE;                    \                                   if( offset_write_to_section(sect, sect->top, buffer, length) != length )  \        return MEM_FAILURE;   \    sect->top += length;  \     return sect->start_mem_address + sect->top - length; \}while(0)MEM_ADDR push_text  (void * buffer, size_t length) {    PUSH_SECTION( memory_map.text );}MEM_ADDR push_rodata(void * buffer, size_t length) {    PUSH_SECTION( memory_map.rodata );}MEM_ADDR push_data  (void * buffer, size_t length) {    PUSH_SECTION( memory_map.data );}MEM_ADDR push_bss   (void * buffer, size_t length) {    PUSH_SECTION( memory_map.bss );}MEM_ADDR push_stack (void * buffer, size_t length) {    SECTION sect = memory_map.stack;    if (sect == NULL)        return MEM_FAILURE;            if ( sect->top < length )        return MEM_FAILURE;                                                             if( offset_write_to_section(sect, sect->top - length, buffer, length) != length )        return MEM_FAILURE;            sect->top -= length;    return sect->start_mem_address + sect->top;}MEM_ADDR pop_stack  (void * buffer, size_t length) {    SECTION sect = memory_map.stack;    if (sect == NULL)        return MEM_FAILURE;            if ( sect->top + length > sect->size )        return MEM_FAILURE;                                  if( offset_read_from_section(sect, sect->top, buffer, length) != length )        return MEM_FAILURE;    sect->top += length;    return sect->start_mem_address + sect->top - length;}// FUNZIONI SPERIMENTALIvoid * get_real_memory_address( MEM_ADDR address ) {    SECTION sect = search_address_section(address);    size_t offset ;        if ( sect == NULL )        return NULL;        offset = address - sect->start_mem_address;    return sect->pointer + offset;}