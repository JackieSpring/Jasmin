#include "registers.h"typedef struct register_struct {    register_size    size;   // byte size of the register    void * address;     // register's memory address} register_struct ;struct register_list_struct {    register_id     nregs;    register_struct * regs_list;};register_list * create_register_list( register_id size ){    if ( size == 0 )        goto cleanup;    register_list * rl = NULL;        rl = calloc( 1, sizeof(register_list) );    if ( rl == NULL )        goto cleanup;        rl->nregs = size;    rl->regs_list = calloc(size, sizeof(register_struct) );    if ( rl->regs_list == NULL )        goto cleanup;        return rl;cleanup:    if ( rl != NULL ) {        if ( rl->regs_list != NULL )            free(rl->regs_list);                free(rl);    }        return NULL;}void destroy_register_list( register_list * regl) {    if ( regl == NULL )        return;        free(regl->regs_list);    free(regl);}/* * @regl    register list where the register has to be added * @regid   ID number that will identify the new register * @size    byte size of the new register * @address memory address that will contains the register data * * @return  -1 if */int add_register_to_list    ( register_list * regl, register_id regid, register_size size, void * address ) {    if ( regl == NULL || regid >= regl->nregs)        goto cleanup;        register_struct target;    target.size = size;    target.address = address;    memset(target.address, 0, target.size);    regl->regs_list[regid] = target;        return 0;cleanup:    return -1;}int del_register_from_list  ( register_list * regl, register_id regid ){    if ( regl == NULL || regid >= regl->nregs)        goto cleanup;        register_struct target = regl->regs_list[regid];    target.size = 0;    target.address = NULL;        return 0;cleanup:    return -1;}/* * @regl    register list from where the register will be written/readden * @regid   ID number of the register * @buffer  buffer where the register's data have to be stored or where to read the new data from, *          the size of the buffer must be at least equal to the size of the register * * @return  number of bytes readden / written*/register_size read_from_register  ( register_list * regl, register_id regid, void * buffer) {    if ( regl == NULL || regid >= regl->nregs || buffer == NULL )        goto cleanup;        register_struct target = regl->regs_list[regid];        if ( target.size == 0 || target.address == NULL )        goto cleanup;        memcpy( buffer, target.address, target.size );        return target.size;cleanup:    return 0;}register_size write_into_register ( register_list * regl, register_id regid, void * buffer) {    if ( regl == NULL || regid >= regl->nregs || buffer == NULL )        goto cleanup;        register_struct target = regl->regs_list[regid];        if ( target.size == 0 || target.address == NULL )        goto cleanup;        memcpy( target.address, buffer, target.size );        return target.size;cleanup:    return 0;}